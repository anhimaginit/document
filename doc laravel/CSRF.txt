CSRF Protection trong Laravel

Laravel có cơ chế bảo vệ khỏi csrf được kích hoạt mặc định. Vì vậy ngay cả khi bạn không biết gì csrf, tại sao cần bảo vệ các ứng dụng khỏi nó bạn vẫn có thể sử dụng nó khá đơn giản :D. Laravel tự động tạo một SCRF "token" trong mỗi phiên làm việc của bạn và được quản lý bởi ứng dụng. Chúng ta sẽ tìm hiểu cách sử dụng trong các phiên bản 4 và 5.

Laravel 4.2
Trong phiên bản 4.x chúng ta có filters. Việc của bạn cần làm chỉ là thêm vào 
app/filters.php

	Route::filter('csrf', function()
	{
			if (Session::token() !== Input::get('_token'))
			{
				throw new Illuminate\Session\TokenMismatchException;
			}
	});
	
Bạn chỉ cần sử dụng nó ở bất kì route nào bạn muốn:
	Route::post('register', array('before' => 'csrf', function()
    {
        return 'You gave a valid CSRF token!';
    }));
	
Và chắc chắn rằng bạn không quên chèn thêm token trong form của bạn:
	<input type="hidden" name="_token" value="<?php echo csrf_token(); ?>">
Laravel 5.0
Phiên bản 5.0 cung cấp Middleware thay thế cho filter. Và đã có 1 bộ các class Middleware được load mặc định, bao gồm cả CSRF. 
trong file app/Http/Kernel.php bạn có thể tìm thấy
class Kernel extends HttpKernel {

    protected $middleware = [
        'Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode',
        'Illuminate\Cookie\Middleware\EncryptCookies',
        'Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse',
        'Illuminate\Session\Middleware\StartSession',
        'Illuminate\View\Middleware\ShareErrorsFromSession',
        'Illuminate\Foundation\Http\Middleware\VerifyCsrfToken',
    ];
	
Class VerifyCsrfToken đã được include trong $middleware, tức là tất cả các 
POST request đã được bảo vệ khỏi CSRF. 
Nhưng chính điều đó lại trở thành vấn đề. 
Rõ rang là không phải tất các POST request đều đến từ một form nào đó, 
có thể nó được gọi từ 1 API hoặc Ajax... 
Vì vậy mòi người bắt đầu tìm kiếm cách loại bỏ CSRF khỏi middleware mặc định. 
Và câu trả lời đơn giản nhất là không include nó trong $middleware array, 
và thêm nó vào bất cứ nơi nào cần thiết như trong phiên bản Laravel 4.

Laravel 5.1 - Vấn đề được giải quết
Vấn đề trên đã được nhìn nhận và được thay đổi trong phiên bản 5.1. Và sau đây là một số điểm mới:
Bạn có thể sử dụng helper csrf_field() để tạo toàn bộ input thay vì chỉ mỗi token. Vì vậy, thay vì:

	<input type="hidden" name="_token" value="<?php echo csrf_token(); ?>">
	Bạn chỉ phải viết:
	{!! csrf_field() !!}
	Vẫn còn VerifyCsrfToken trong $middleware array
	protected $middleware = [
        \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,
        \App\Http\Middleware\EncryptCookies::class,
        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,
        \Illuminate\Session\Middleware\StartSession::class,
        \Illuminate\View\Middleware\ShareErrorsFromSession::class,
        \App\Http\Middleware\VerifyCsrfToken::class,
    ];
	
	Nhưng bạn có thể loại bỏ nó khỏi những URL nhất định mà bạn muốn, 
	để là được điều đó mở app/Http/Middleware/VerifyCsrfToken.php thêm thuộc tính $except:
	
	<?php

	namespace App\Http\Middleware;

	use Illuminate\Foundation\Http\Middleware\VerifyCsrfToken as BaseVerifier;

	class VerifyCsrfToken extends BaseVerifier
	{
		/**
		 * The URIs that should be excluded from CSRF verification.
		 *
		 * @var array
		 */
		protected $except = [
			'ajax/*',
		];
	}
	
	Lưu ý rằng (*) là một biểu tượng để quy định 1 rule nào đấy và rule này mô tả các URL chứ ko phải route
